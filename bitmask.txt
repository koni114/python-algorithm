** 비트마스크(Bitmask) 
- 비트(bit)연산을 사용해서 부분 집합을 표현할 수 있음
  파이썬도 &, |, ~, ^ 는 비트 연산에 사용 됨
^(xor) : 다르면 1, 같으면 0
~(not) : 반대로 생각해주세요 -_-
ex)
A : 0011
B : 0101 일때

A & B : 0001
A | B  : 0111
~A    : 1100
A ^ B : 0110

** 비트연산(bitwise operation)
- 두 수 A와 B를 비트 연산 하는 경우에는 가장 뒤의 자리부터 하나씩 연산 수행
- not 연산의 경우에는 자료형에 따라 결과가 달라진다
-> 8비트 자료형, 32비트 자료형에 따라서 달라짐
- shift left(<<) 와 shift right(>>) 연산이 있음 
A << B(A를 왼쪽으로 B비트만큼 민다)
1 << 0 = 1(10)
1 << 1 = 2(100)
1 << 2 = 4(1000)
1 << 3 = 8(10000)
1 << 4 = 16(10000)
3 << 3 = 24(11000)
5 << 10 = 5120(101000000000)

- A<<B는 A X 2^B 와 같다
- A>>B는 A / 2^B 와 같다
- (A+B) / 2는 (A+B) >>1로 쓸 수 있다
- 어떤 수가 홀수 인지 판별하는 if (N % 2 == 1)은 if(N&1)로 줄여 쓸 수 있음

- ** 정수로 집합을 나타낼 수 있음
ex) {1, 3, 4, 5, 9} = 570 = 2^1 + 2^3 + 2^4 + 2^5 + 2^9
0이 포함되었는지 검사
570 & 2^0 = 570 & (1<<0) = 0
1이 포함되었는지 검사
570 & 2^1 = 570 & (1<<1) = 2
2이 포함되었는지 검자
570 & 2^2 = 570 & (1<<2) = 0
3이 포함되어 있는지 검사
570 & 2^3 = 570 & (1<<3) = 8

추가하기 --> |
제거하기 --> & ~
전체 집합 (1 << N) - 1
공집합 0

현재 집합이 S일때
i를 추가 : S | (1 << i)
i를 검사 : S & (1 << i)
i를 제거 : S & ~(1 << i)
i를 토글(0을 1로, 1을 0으로) : S ^ (1 << i)

- 물론 배열을 사용하는 것이 더욱 편리하지만, 비트마스크를 사용하는 이유는
  집합을 배열의 인덱스로 표현할 수 있기 때문이다.
  상태 다이나믹을 할 때 자주 사용하게 된다
