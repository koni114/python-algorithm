** 계획
1단계 : BaekJoon 노트 문제들 전부 풀기

01_기본 - 완료

02_Stack&Queue - 완료
스택(10828)
괄호(9012)
쇠막대기(10799)
에디터(1406)
큐(10845)
조세퍼스 문제(1158)
덱(10866)
알파벳 개수(10808)
문자열 분석(10820)
단어 길이 재기(2743)
ROT13(11655)
네 수(10824)
접미사 배열(11656)


03_dp 미완료
1로 만들기(1463)
2 X n 타일링(11726)
2 X n 타일링2(11727)
1, 2, 3 더하기(9095)
붕어빵 판매하기(11052)
쉬운 계단 수(10844)
오르막 수(11057)
이친수(2193)
스티커(9465)
포도주 시식(2156)
가장 긴 증가하는 부분 수열(11053)
가장 큰 증가하는 부분 수열(11055)
가장 긴 감소하는 부분 수열(11722)
가장 긴 바이토닉 부분 수열(11054)
연속합(1912)
계단 오르기(2579)
제곱수의 합(1699)
- 타일 채우기(2133)
- 파도반 수열(9461)
- 합분해(2225)
- 암호 코드(2011)


04_수학 : 완료
나머지(10430)
최대공약수와 최소공배수(2609)
최소공배수(1934)
GCD 합(9613)
진법 변환 2(11005)
진법 변환(2745)
2진수 8진수(1373)
8진수 2진수(1212)
-2진수(2089)
-> -2진수는 2진수와 동일하지만, 나머지가 -가 나오면 안되는 것을 조심
    홀수의 수를 나눌때 어떻게 되는지 생각해보자

Base Conversion(11576)
소수 찾기(1978)
소수 구하기(1929)
1은 소수가 아니다!
골드바흐의 추측(6588)
시간 초과 : 두 소수의 조합을 나타 낼 때 2중 for문 쓸 필요가 없음
                 case 마다 에라토스테네스의 체를 만들 필요가 없음

소인수분해(11653)
팩토리얼(10872)
팩토리얼 0의 개수(1676)
조합 0의 개수(2004)
- 생각보다 고생 많이 함.  너무 복잡하게 생각하지 말고,
   m / 5 + m / 5^2 + m / 5^3 ... 으로 생각하자 

05_정렬: 완료
수 정렬하기2(2751)
좌표 정렬하기(11650)
좌표 정렬하기2(11651)
나이순 정렬(10814)
국영수(10825)
수 정렬하기 3(10989)
카드(11652)
K번째 수(11004)
버블소트(1377)

06_그래프: 미완료
DFS와 BFS(1260)
연결 요소(11724)
이분 그래프(1707)
순열 사이클(10451)
반복 수열(2331)
Term Project(9466)
단지번호붙이기(2667)
섬의 개수(4963)
미로탐색(2178)
토마토(7576)
- 다리 만들기(2146)


07_트리 : 완료
트리의 순회(1991)
트리의 부모 찾기(11725)
트리의 지름(1167)

08. 그리디 알고리즘 : 미완료
동전 0(11047)
회의실 배정(1931)
ATM(11399)
잃어버린 괄호(1541)
**수 묶기(1744)
 deque 로 선언 후, sorted 하면 다시 list로 바뀜 
대회 or 인턴(2875)
30(10610)
병든 나이트(1783)
** NMK(1201)
-> 왠만하면 나누기는 안하는 것이 좋다
-> 생각을 잘못해서 너무 오래 걸린 문제. 나머지가 있는 경우 단순히 +1을 해주었는데
그게 아니라 나머지 개수 만큼 증가해줘야 했었는데 그렇지 못함
-> 배열 길이가 나눠준 값만큼 커지기 때문에 그냥 해당 값에 +1만 해주면 됨

행렬(1080)
-> 배열에 대한 일치 여부를 == 를 통해 파악 가능!
- 롤러코스터(2873)

09. 분할 정복 : 미완료
단순 분할 정복
숫자 카드(10815)
숫자 카드2(10816)
and 조건은, & 아니라 and!!! 
배열 합치기(11728)
종이의 개수(1780)
하노이 탑 이동 순서(11729)
트리의 순회(2263)
-> 재귀의 한계가 있어서 계속 런타임 에러가 뜸..
sys.setrecursionlimit(10**6) 을 통해 해결
-> 함수 parameter setting이 핵심이다.
-> inorder의 root index를 빠르게 찾기 위해 dict type을 이용
solve(is, ie, ps, pe)

쿼드트리(1992)
별찍기 - 10(2447)
- 별찍기 - 11(2448)
**Z(1074)
-> 핵심은, r,c를 찾기 위해서 완전 탐색을 해서는 안된다.
    4등분 할때, if, elif를 통해 해당 위치로 계속 찾아가는 것이 핵심.
-> 푸는데 오래 걸렸던 이유: 하나의 case에 대해서 오류 발생.
결과적으로는 집중해서 푸는 것이 실제로는 중요!

버블 소트(1517)
-> 핵심은 그대로 버블 소트를 수행하게 되면 시간 초과가 발생하게 됨.
- >merge sort를 구현하는데, mid를 기준으로 오른쪽 배열에서 값 하나씩 뽑을때마다 왼쪽에 있는 배열의 길이
  를 계속 더해주면 된다. 
-> 앞으로의 이런 응용은 가능 할 것인가?

** o(N^2) <= 1초 이려면 N은 최대 몇까지 가능한 것일까?
10 ^ (8 // 2) -> 10 ^ 4 : 즉 1만 이하여야 가능하다.. 

** o(lgN * N) <= 1초 이려면?
N : 5백만

** o(N ^ 3) <= 1초
N : 500 


- 가장 가까운 두 점(2261)


10. 이분 탐색으로 정답 찾기 : 완료
랜선 자르기(1654) 
- 나누기 할때 무조건 0 조심
  최소 값이 몇인지를 생각하자
나무 자르기(2805)
공유기 설치(2110)
i = 0 
k for range(i, 10): 
  i = 3
라고 해도, for문은 0부터 9까지 간다... 
중량제한(1939)
놀이 공원(1561)

11. 완전 탐색 part 1 : 완료
집합(11723)
다음 순열(10972)
이전 순열(10973)
모든 순열(10974)
순열의 순서(1722)

12. 완전 탐색 part 2 : 미완료
날짜 계산(1476)
리모컨(1107)
-> 이문제야 말로, 예외처리가 너무나 많기 때문에, 모든 경우에 대해서 brute force를
   사용하는것이 가장 간단하다..
1, 2, 3 더하기(9095)
차이를 최대로(10819)
외판원 순회 2(10971)
로또(6603)
숨바꼭질(1697)
소수 경로(1963)
DSLR(9019)

- 퍼즐(1525)
1 2 3
4 5 6
7 8 9 
라는 2차원 배열을 1차원 배열로 생각하고, bfs로 이동 할때,
2차원 좌표 -> 1차원 인덱스로 변경하기 위한 방법은,
3*x+y
역으로, 1차원 인덱스 -> 2차원 좌표로 변경
x = i // 3
y = i % 3

- 물통(2251)
3차원 배열이 필요가 없다 -> why? : a,b 의 물의 양만 알면 c 는 자동으로 계산
완전 탐색의 N 제한 계산은 보통, 모든 경우의 수의 개수를 생각하면 된다
상태를 어떻게 나타낼 것인가? 와, 가중치가 1인가를 알아보는 것이
bfs의 핵심

암호 만들기(1759)
N-Queen(9663)
- 스도쿠(2580)
노가다 하면(-> 일일이 2차원 배열로 표현) 가능하다.
하지만 이건 아닌거 같다.
자꾸 연습해야 느니, 최대한 2차원 배열의 표현을 1차원 배열로 표현해보자
일반적으로 백 트래킹의 재귀적 탐색은, 단계로 나눌 수 있다.
1. 데이터 저장 방식
2. 다음 단계로 가능한지 여부 파악
 -> 가능 하면, 해당 값을 True 로 변경
 -> 다음 단계 이동
 -> 해당 값을 다시 False 로 변경
답 찾으면, return 하면 안되고, 반드시 sys.exit(0)

- 알파벳(1987)
-> 이번 문제을 통해 파이썬 재귀는 굉장히 느리다! 라는 것을 알게됨
   왠만하면 재귀쓰지말고 while로 stack에 담는 방법을 이용하자

- 부분집합의 합(1182)

13. 자료구조 : 미완료
검열(3111)
문자열 폭발(9935)
- 히스토그램에서 가장 큰 직사각형(6549)
- 오아시스 재결합(3015)
- 집합의 표현(1717)
- 바이러스(2606)
- 최소 힙(1927)
- Ceiling Function(12767)
- 회사에 있는 사람(7785)
- 듣보잡(7785)


2단계 : 전체적으로 백준 알고리즘 어려웠던 부분 정리

3단계 : BJ 시뮬레이션 문제 풀기
codeground format에 맞추어 해보기
- 로봇 시뮬레이션(2174)
- Puyo Puyo(11559)
- 체스판 다시 칠하기(1018)
- 연구소(14502)
- 로봇 청소기(14503)
- 퇴사(14501)
- 벽 부수고 이동하기(2206)
- 통나무 옮기기(1938)
- 로봇(1726)
- 테트로미노(14500)
- 사탕 게임(3085)
- 열쇠(9328)
- 가스관(2931)
- 퍼즐(1525)

4단계 : programmers 알고리즘 문제 풀기

