** 분할 정복(Divided and conquer)
- 분할 정복은 문제를 2개 또는 그 이상의 작은 부분 문제로 나눈 다음 푸는 것
- 푼 다음에는 다시 합쳐서 정답을 구할 때도 있음(정복)
- 대표적인 분할 정복 알고리즘
 ex) 퀵 소트, 머지 소트, 큰 수 곱셈(카라추바 알고리즘), FFT
- 분할 정복과 다이나믹은 문제를 작은 문제로 나눈 다는 점은 동일
- 분할 정복이 DP와의 가장 큰 차이점 : 문제가 겹치지 않음
- 다이나믹: 문제가 겹쳐서 겹치는 것을 Memorization으로 해결

** 이분 탐색
- 정렬되어 있는 리스트에서 어떤 값을 빠르게 찾는 알고리즘
- 리스트의 크기를 N이라고 했을 때, lgN의 시간이 걸린다
- 시간 복잡도가 lgN인 이유는 크기가 N인 리스트를 계속 절반으로 나누기 때문
- 2^k = N, k = lgN(밑 = 2)
- 코드 구현
 -> DP랑 비슷하므로, 재귀적 함수를 구현해서 구해도 되고,
    while 문을 이용해서 left <= right 를 조건으로 구현해도 됨
- 일반적으로 이분 탐색은 어떤 값을 찾는 과정이다. 다른 방법으로도 찾을수 있겠지?
 but 성능이 좋다. 즉, N의 제한이 굉장이 Tight 할 때 사용하게 될 것이다.

** Tip
ctrl + c : 무한루프 while문을 빠져나감

- merge sort
중요한 것은 재귀를 응용한다는 점.
함수 내에 2번의 재귀가 돌아간다.  -> 어떨 때 사용 하는 것일까?
중간 포인트를 기점으로, 반복되는 행동이 있을때, 분할 정복의 기본!

** 분할 정복 문제 풀기
분할 정복 문제는 어떻게 함수를 만들어야 할지 결정해야 한다
함수 -> 문제를 푸는 함수
그 함수 내에서는 작은 문제를 어떻게 호출해야 할지 결정
만약에 부분 문제의 정답을 합쳐야 하는 경우에는 합치는 것을 어떻게 해야할지 결정

** 분할 정복의 핵심(?)
- 언제 return을 시킬 것인가, left, right 의 값이 같아질떄?, left > right 일떄?
  생각을 잘해서 설계해야한다.
- 같은 단계를 계속해서 반복한다. 없으면, 쪼개고, 없으면 쪼개고... 
  dp는 한번의 선택이 optimal value에 영향을 미치지만, 분할정복은 그런 개념이 아니다

